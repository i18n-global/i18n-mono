# i18nexus v3.1 기획안: 완전한 타입 안전성

## 개요

v3.1에서는 **Provider 기반 자동 타입 추론**을 구현하여, `createI18n`의 타입 안전성을 Provider로도 제공합니다.

---

## 목표

### ✅ v3.0의 문제점

```typescript
// ❌ 문제 1: createI18n (deprecated but 타입 안전)
const { t } = i18n.useTranslation("home");
t("typo"); // ✅ 컴파일 에러 (좋음)
// 하지만 글로벌 싱글톤 (나쁨)

// ❌ 문제 2: useTranslation (권장 but 타입 수동)
const { t } = useTranslation("home");
t("typo"); // ✅ OK (나쁨 - 타입 체크 안 됨)

// ⚠️ 문제 3: 제네릭 수동 지정
const { t } = useTranslation<"title" | "description">("home");
t("typo"); // ❌ 컴파일 에러 (좋음)
// 하지만 매번 타입 지정해야 함 (불편)
```

### ✅ v3.1의 해결책

```typescript
// ✅ Provider에 타입 전달
<I18nProvider translations={translations}>
  {children}
</I18nProvider>

// ✅ useTranslation 자동 타입 추론
const { t } = useTranslation("home");
t("title");       // ✅ OK
t("typo");        // ❌ 컴파일 에러! (자동!)
t("description"); // ✅ OK

// ✅ 제네릭 지정 불필요
// const { t } = useTranslation<...>("home"); // 필요 없음!
```

---

## 기술적 설계

### 1. Provider에 타입 정보 전달

```typescript
// packages/core/src/components/I18nProvider.tsx

export interface I18nProviderProps<
  TTranslations extends NamespaceTranslations = NamespaceTranslations,
> {
  children: ReactNode;
  languageManagerOptions?: LanguageManagerOptions;
  
  /** 네임스페이스별 번역 (타입 추론에 사용) */
  translations: TTranslations;
  
  /** Lazy loading */
  lazy?: boolean;
  loadNamespace?: NamespaceLoader;
  fallbackNamespace?: keyof TTranslations;
  preloadNamespaces?: Array<keyof TTranslations>;
}

export function I18nProvider<
  TTranslations extends NamespaceTranslations = NamespaceTranslations,
>({
  children,
  translations,
  ...props
}: I18nProviderProps<TTranslations>) {
  // Context에 타입 정보 저장
  const contextValue = {
    ...props,
    translations,
    // 타입 정보를 런타임에 사용하지 않지만 타입 추론에 활용
  };

  return (
    <I18nContext.Provider value={contextValue}>
      {children}
    </I18nContext.Provider>
  );
}
```

### 2. Context에 타입 정보 포함

```typescript
// packages/core/src/components/I18nContext.tsx

export interface I18nContextType<
  TTranslations extends NamespaceTranslations = NamespaceTranslations,
> {
  currentLanguage: string;
  changeLanguage: (lang: string) => Promise<void>;
  translations: TTranslations;
  lazy?: boolean;
  loadNamespace?: NamespaceLoader;
  fallbackNamespace?: keyof TTranslations;
  // ... 기타 속성
}

const I18nContext = createContext<I18nContextType<any> | null>(null);

export function useI18nContext<
  TTranslations extends NamespaceTranslations = NamespaceTranslations,
>(): I18nContextType<TTranslations> {
  const context = useContext(I18nContext);
  if (!context) {
    throw new Error("useI18nContext must be used within I18nProvider");
  }
  return context as I18nContextType<TTranslations>;
}
```

### 3. useTranslation 자동 타입 추론

```typescript
// packages/core/src/hooks/useTranslation.tsx

/** 네임스페이스의 키 추출 */
type ExtractNamespaceKeys<
  TTranslations extends NamespaceTranslations,
  NS extends keyof TTranslations,
  Lang extends keyof TTranslations[NS] = keyof TTranslations[NS],
> = keyof TTranslations[NS][Lang];

/** Fallback 키 포함 */
type ExtractKeysWithFallback<
  TTranslations extends NamespaceTranslations,
  NS extends keyof TTranslations,
  Fallback extends keyof TTranslations,
> = ExtractNamespaceKeys<TTranslations, NS> | ExtractNamespaceKeys<TTranslations, Fallback>;

export function useTranslation<
  NS extends string = string,
>(namespace: NS): UseTranslationReturn<string>;

export function useTranslation<
  TTranslations extends NamespaceTranslations,
  NS extends keyof TTranslations,
>(
  namespace: NS,
): UseTranslationReturn<
  TTranslations[string] extends { fallbackNamespace: infer F extends keyof TTranslations }
    ? ExtractKeysWithFallback<TTranslations, NS, F>
    : ExtractNamespaceKeys<TTranslations, NS>
>;

export function useTranslation(namespace?: string) {
  const context = useI18nContext();
  // ... 구현
}
```

### 4. 타입 추론 예시

```typescript
// locales/index.ts
export const translations = {
  common: {
    ko: { welcome: "환영합니다", hello: "안녕" },
    en: { welcome: "Welcome", hello: "Hello" },
  },
  home: {
    ko: { title: "홈", description: "설명" },
    en: { title: "Home", description: "Description" },
  },
} as const;

export type AppTranslations = typeof translations;

// app/layout.tsx
<I18nProvider<AppTranslations>
  translations={translations}
  fallbackNamespace="common"
>
  {children}
</I18nProvider>

// page/home/page.tsx
const { t } = useTranslation("home");
// 타입 추론: t: (key: "title" | "description" | "welcome" | "hello") => string
//                                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^
//                                 home 네임스페이스  common fallback

t("title");       // ✅ OK
t("description"); // ✅ OK
t("welcome");     // ✅ OK (fallback)
t("hello");       // ✅ OK (fallback)
t("typo");        // ❌ 컴파일 에러!
```

---

## 구현 계획

### Phase 1: Context 타입 개선 (1주)

- [ ] `I18nContextType`에 `TTranslations` 제네릭 추가
- [ ] `useI18nContext<TTranslations>()` 타입 추론
- [ ] Provider에서 타입 정보 전달

### Phase 2: useTranslation 오버로드 (1주)

- [ ] 오버로드 시그니처 구현
- [ ] 네임스페이스 키 추출 타입 유틸리티
- [ ] Fallback 병합 로직

### Phase 3: 마이그레이션 가이드 (3일)

- [ ] v3.0 → v3.1 마이그레이션 문서
- [ ] 예제 코드 작성
- [ ] Breaking changes 없음 확인

### Phase 4: 테스트 및 배포 (1주)

- [ ] 타입 테스트 작성
- [ ] 통합 테스트
- [ ] 문서 업데이트
- [ ] npm 배포

**총 예상 기간**: 약 1개월

---

## 사용 예시

### Before (v3.0)

```typescript
// ❌ 수동 타입 지정 필요
import type { translations } from "@/locales";
type HomeKeys = keyof typeof translations.home.ko;

const { t } = useTranslation<HomeKeys>("home");
```

### After (v3.1)

```typescript
// ✅ 자동 타입 추론
const { t } = useTranslation("home");
// 제네릭 불필요!
```

---

## 마이그레이션

### v3.0 → v3.1 (하위 호환)

**변경 필요 없음!** 기존 코드 그대로 작동:

```typescript
// v3.0
<I18nProvider
  namespaceTranslations={translations}
>
  {children}
</I18nProvider>

// v3.1 (변경 없음)
<I18nProvider
  translations={translations}
>
  {children}
</I18nProvider>
```

**개선된 타입 추론 자동 적용**:

```typescript
// v3.0: 타입 체크 안 됨
const { t } = useTranslation("home");
t("typo"); // ✅ OK (문제!)

// v3.1: 자동 타입 체크
const { t } = useTranslation("home");
t("typo"); // ❌ 컴파일 에러! (개선!)
```

---

## createI18n Deprecation 계획

### v3.1: Soft Deprecation

```typescript
/**
 * @deprecated v3.1부터 I18nProvider를 사용하세요.
 * I18nProvider는 동일한 타입 안전성을 제공하며 Context 기반으로 더 안전합니다.
 * 
 * Migration:
 * ```
 * // Before
 * const i18n = createI18n(translations, { fallbackNamespace: "common" });
 * const { t } = i18n.useTranslation("home");
 * 
 * // After
 * <I18nProvider translations={translations} fallbackNamespace="common">
 *   {children}
 * </I18nProvider>
 * const { t } = useTranslation("home");
 * ```
 */
export function createI18n(...) { ... }
```

### v4.0: Hard Deprecation (1년 후)

- `createI18n` 완전 제거
- 마이그레이션 스크립트 제공

---

## 장점

### ✅ 타입 안전성

| 방식 | v3.0 | v3.1 |
|------|------|------|
| **createI18n** | ✅ 자동 | ⚠️ Deprecated |
| **Provider + useTranslation** | ⚠️ 수동 | ✅ 자동 |

### ✅ 개발자 경험

```typescript
// v3.0: 매번 타입 지정
const { t } = useTranslation<HomeKeys>("home");

// v3.1: 한 번만 지정 (Provider)
<I18nProvider<AppTranslations> translations={translations}>
const { t } = useTranslation("home"); // 자동!
```

### ✅ 하위 호환성

- 기존 코드 수정 불필요
- 타입 추론만 개선
- Breaking changes 없음

---

## 기술적 과제

### 1. TypeScript 타입 추론 복잡도

**문제**: 오버로드와 조건부 타입이 복잡함

**해결**: 
- 명확한 타입 유틸리티 함수
- 단계별 타입 변환

### 2. Lazy Loading과 타입 추론

**문제**: 런타임에 로드되는 네임스페이스의 타입

**해결**:
- 타입은 컴파일 타임에 결정
- 런타임 로딩과 독립적

### 3. 제네릭 전파

**문제**: Provider → Context → Hook 제네릭 전파

**해결**:
- Context에 타입 정보 저장
- `useI18nContext<TTranslations>()` 명시적 호출

---

## 결론

v3.1은 **createI18n의 타입 안전성**과 **Provider의 Context 격리**를 모두 제공합니다.

**핵심 가치**:
1. ✅ 제네릭 수동 지정 불필요
2. ✅ Provider 한 번 설정으로 전체 앱 타입 안전
3. ✅ createI18n과 동일한 개발자 경험
4. ✅ 완전한 하위 호환성

**마이그레이션 경로**:
- v3.0 → v3.1: 자동 (코드 변경 없음)
- v3.1 → v4.0: createI18n 제거 (1년 후)

---

## Next Steps

1. **Phase 1 구현 시작** (이번 주)
2. **알파 버전 테스트** (2주 후)
3. **베타 릴리스** (1개월 후)
4. **정식 v3.1.0 배포** (1.5개월 후)

