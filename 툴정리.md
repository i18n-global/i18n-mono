다국어 관리(i18n) 라이브러리는 크게 **핵심 프레임워크**, **React 바인딩**, **Next.js 전용 라이브러리**, 그리고 이들과 함께 사용되는 **Scanner/Extraction 도구**로 구분됩니다. 이 보고서에서는 각 라이브러리의 특징, 기능, 그리고 번역 키 추출 도구들을 종합적으로 분석합니다.

## 핵심 i18n 프레임워크

### i18next

i18next는 JavaScript 생태계에서 가장 널리 사용되는 국제화 프레임워크로, 주간 약 **350만 다운로드**를 기록하고 있습니다[1]. 프레임워크에 구애받지 않는 설계로 React, Vue, Angular, Node.js 등 다양한 환경에서 사용할 수 있습니다.

**주요 특징:**

- **플러그인 아키텍처**: 언어 감지(i18next-browser-languagedetector), 백엔드 로딩, ICU 지원 등을 플러그인으로 확장
- **네임스페이스 지원**: 번역 파일을 논리적으로 분리하여 필요한 것만 로딩
- **복수형 처리**: CLDR 표준 기반으로 `_one`, `_other` 등의 접미사 사용
- **TypeScript 지원**: `CustomTypeOptions` 인터페이스를 통한 타입 정의

```tsx
// i18next TypeScript 설정 예시
declare module "i18next" {
  interface CustomTypeOptions {
    defaultNS: "common";
    resources: {
      common: typeof import("./locales/en/common.json");
    };
  }
}
```

### react-i18next

react-i18next는 i18next의 React 전용 바인딩으로, **주간 약 200만 다운로드**를 기록합니다[2]. `useTranslation` 훅과 `Trans` 컴포넌트를 통해 React 컴포넌트 내에서 번역을 쉽게 사용할 수 있습니다.

**주요 API:**

- `useTranslation()`: 훅 기반 번역 접근[6]
- `withTranslation()`: HOC 패턴 지원
- `<Trans>`: JSX 내 리치 텍스트 번역 컴포넌트
- 비동기 번역 리소스 로딩으로 초기 번들 크기 최적화[7]

### react-intl (FormatJS)

FormatJS의 react-intl은 **ICU Message Format**을 네이티브로 지원하는 라이브러리입니다.
국제 표준인 ICU 문법을 기반으로 하여 다른 프로그래밍 환경과의 호환성이 뛰어납니다.

**ICU vs i18next 복수형 비교:**

| 라이브러리 | 복수형 문법                                     |
| ---------- | ----------------------------------------------- |
| react-intl | `{count, plural, one {# item} other {# items}}` |
| i18next    | `"key_one": "# item"`, `"key_other": "# items"` |

react-intl의 ICU 문법은 단일 키에 모든 복수형을 포함하여 관리가 용이하지만, i18next의 분리된 키 방식이 가독성 면에서 더 깔끔하다는 평가도 있습니다.

### LinguiJS

LinguiJS는 **매크로 기반**의 국제화 라이브러리로, 컴파일 타임에 메시지를 변환합니다.
번들 크기가 **약 2-3kb**로 매우 경량입니다.

```jsx
import { t, plural } from "@lingui/core/macro";

// 기본 사용
t`Hello World!`; // → "Salut le monde!"

// 복수형
plural(count, {
  one: "# book",
  other: "# books",
}); // → "42 livres"
```

**특징:**

- `t`, `Trans`, `plural`, `select` 매크로 제공
- 빌드 타임 메시지 변환으로 런타임 오버헤드 최소화[9]
- Vanilla JS부터 React까지 지원

## Next.js 전용 라이브러리

### next-intl

next-intl은 Next.js **App Router와 Server Components를 완벽하게 지원**하는 국제화 라이브러리입니다[10]. Jan Amann이 개발했으며, Next.js 커뮤니티에서 가장 권장되는 라이브러리 중 하나입니다[11].

**핵심 기능:**

- **ICU Message Syntax**: 보간, 기수/서수 복수형, 열거형 라벨 선택, 리치 텍스트[10]
- **날짜/시간/숫자 포맷팅**: 서버/클라이언트 시간대 차이 자동 처리
- **타입 안전성**: 메시지 키 자동완성 및 컴파일 타임 체크[12][13]
- **국제화된 라우팅**: 언어별 고유 경로명 제공

```tsx
// next-intl TypeScript 설정
declare module "next-intl" {
  interface AppConfig {
    Locale: "en" | "ko" | "ja";
    Messages: typeof import("./messages/en.json");
  }
}
```

**자동 타입 생성**: `createMessagesDeclaration` 옵션을 통해 메시지 JSON 파일에서 TypeScript 타입을 자동 생성할 수 있습니다[13].

### next-i18next

next-i18next는 **Pages Router** 환경에서 i18next와 react-i18next를 Next.js에 통합하는 라이브러리입니다. App Router를 사용하는 경우에는 next-i18next 없이 직접 i18next와 react-i18next를 사용하는 것이 권장됩니다.

**특징:**

- `serverSideTranslations`를 통한 SSG/SSR 지원
- `appWithTranslation` HOC로 번역 컨텍스트 제공
- JSON 파일 기반 번역 관리

### next-translate

next-translate은 **약 1kb**의 초경량 라이브러리로, Next.js에 최적화된 번역 솔루션입니다.
Webpack 플러그인을 통해 페이지별로 필요한 번역만 자동 로딩합니다.

**장점:**

- 자동 페이지 최적화 (SSG 지원)
- 네임스페이스별 번역 파일 분리
- `useTranslation` 훅, `Trans` 컴포넌트 제공[17]
- React 18 Server/Client Components 지원

```jsx
// i18n.json 설정
{
  "locales": ["en", "ko", "ja"],
  "defaultLocale": "en",
  "pages": {
    "*": ["common"],
    "/": ["home"]
  }
}

```

## 특화된 i18n 라이브러리

### typesafe-i18n

typesafe-i18n은 **완전한 타입 안전성**을 핵심 기능으로 하는 라이브러리입니다. Generator가 기본 로케일 파일을 분석하여 TypeScript 타입을 자동 생성합니다.

**특징:**

- **번들 크기**: i18nString 948 bytes, i18nObject 1089 bytes, i18n 1119 bytes (gzipped)[18]
- Template Literal Types를 활용한 타입 추론
- 외부 의존성 없음
- React, Vue, Svelte, Angular, Node.js 등 지원

### Intlayer

Intlayer는 **컴포넌트 레벨에서 번역을 선언**하는 선언적 접근 방식의 라이브러리입니다. `.content.ts` 파일로 번역 콘텐츠를 컴포넌트 근처에 배치합니다.

```tsx
// component.content.ts
export default {
  title: {
    en: "Hello",
    ko: "안녕하세요",
    ja: "こんにちは",
  },
};
```

**장점:**

- 빌드 타임 분석으로 사용량 추론
- 강력한 TypeScript 지원
- Visual Editor/AI 번역 통합 가능[20]

### gt-next (General Translation)

gt-next는 **AI 기반 자동 번역**을 제공하는 현대적인 i18n 라이브러리입니다. `<T>` 컴포넌트로 JSX를 감싸면 자동으로 번역됩니다.

```jsx
<T>
  <p>You can write any JSX as children of the {"<T>"} component.</p>
</T>
```

### rosetta

rosetta는 **298 bytes**의 초경량 라이브러리로, 가장 기본적인 i18n 기능만 제공합니다[24]. 복잡한 기능이 필요 없는 간단한 프로젝트에 적합합니다.

## Scanner 및 Extraction 도구

### i18next-scanner

i18next-scanner는 코드에서 **번역 키를 스캔하여 추출**하고 i18n 리소스 파일에 병합하는 도구입니다[25][26].

**주요 기능:**

- `parseFuncFromString()`: JS 함수에서 키 추출[25]
- `parseTransFromString()`: Trans 컴포넌트 파싱
- `parseAttrFromString()`: HTML 속성(`data-i18n`)에서 추출
- Gulp/Grunt 스트림 API 지원
- 커스텀 transform 함수로 확장 가능

```jsx
// i18next-scanner.config.js 예시
module.exports = {
  input: ["src/**/*.{js,jsx}"],
  output: "./",
  options: {
    func: {
      list: ["t", "i18next.t"],
      extensions: [".js", ".jsx"],
    },
    trans: {
      component: "Trans",
      i18nKey: "i18nKey",
    },
  },
};
```

### i18next-parser

i18next-parser는 **5가지 빌트인 lexer**(JavaScript, JSX, HTML, Handlebars, TypeScript+tsx)를 제공하는 파싱 도구입니다[27].

**특징:**

- Vue.js 3.0 파일 지원
- 로케일 및 네임스페이스별 카탈로그 파일 생성
- 미사용 키 백업 기능

### i18next-cli

i18next-cli는 **공식 통합 CLI 도구**로, 키 추출, 코드 린팅, 로케일 동기화, 타입 생성을 한 번에 처리합니다[28].

### @formatjs/cli

FormatJS의 CLI는 react-intl 프로젝트에서 **메시지 추출 및 컴파일**을 담당합니다[29][30].

```bash
# 메시지 추출
formatjs extract 'src/**/*.ts*' --out-file lang/en.json \\
  --id-interpolation-pattern '[sha512:contenthash:base64:6]'

# 컴파일
formatjs compile lang/en.json --out-file compiled/en.json

```

**지원 TMS 포맷:**

- Crowdin, Locize, Lokalise, Smartling, Transifex 등[29]

### @lingui/cli

LinguiJS의 CLI는 **매크로 기반 메시지 추출**을 수행합니다[31][32].

```bash
# 추출
lingui extract [files...] --clean --overwrite

# 컴파일
lingui compile --typescript

```

**특징:**

- `-watch` 모드로 실시간 추출
- `/*i18n*/` 주석으로 명시적 마킹
- `lingui-extract-ignore` 주석으로 제외

### i18n-ally (VS Code Extension)

i18n-ally는 **VS Code 확장 프로그램**으로, 다양한 i18n 라이브러리를 지원합니다[33][34].

**기능:**

- **인라인 어노테이션**: 코드에서 번역 키 미리보기
- **누락 번역 리포트**: 빠진 번역 자동 감지
- **기계 번역**: Google, DeepL 등 연동
- **코드에서 추출**: 하드코딩된 텍스트를 번역 키로 변환
- **에디터 UI**: 번역 검토 시스템

### @simplelocalize/i18n-key-extract

모듈러 CLI 도구로 **여러 전략**(i18next, react-intl, data-i18n-key, EJS, Apple, Android)을 지원합니다[35].

```bash
# i18next 키 추출
i18n-key-extract --strategy i18next --src "src/**/*.{js,ts,jsx,tsx}"

# react-intl 키 추출
i18n-key-extract --strategy react-intl --src "src/**/*.{js,jsx,ts,tsx}"

```

## Locale 위치 및 useTranslation 파라미터 분석

### Locale 위치 (파일 구조)

| 라이브러리         | Locale 파일 위치                      | Locale 설정 위치                      |
| ------------------ | ------------------------------------- | ------------------------------------- |
| **react-i18next**  | `locales/{locale}/common.json`        | `i18n.js`의 `resources` 객체          |
| **next-i18next**   | `public/locales/{locale}/common.json` | `next-i18next.config.js`의 `i18n`     |
| **next-intl**      | `messages/{locale}.json`              | `i18n.ts`의 `locales` 배열            |
| **next-translate** | `locales/{locale}/common.json`        | `i18n.json`의 `locales` 배열          |
| **react-intl**     | `src/messages/{locale}.json`          | 컴포넌트 내 `IntlProvider`의 `locale` |
| **LinguiJS**       | `src/locales/{locale}/messages.js`    | `lingui.config.js`의 `locales`        |
| **typesafe-i18n**  | `src/i18n/{locale}/index.ts`          | 런타임 상태로 관리                    |
| **rosetta**        | 코드 내 직접 정의 (`i18n.set()`)      | `i18n.locale()` 호출                  |

### useTranslation 첫 번째 파라미터

| 라이브러리         | Hook 이름           | 첫 번째 파라미터 | 필수 여부 | 설명                                       |
| ------------------ | ------------------- | ---------------- | --------- | ------------------------------------------ |
| **react-i18next**  | `useTranslation()`  | 네임스페이스     | 선택      | `useTranslation('common')` 또는 생략 가능  |
| **next-i18next**   | `useTranslation()`  | 네임스페이스     | 선택      | `useTranslation('common')` 또는 생략 가능  |
| **next-intl**      | `useTranslations()` | 네임스페이스     | 선택      | `useTranslations('common')` 또는 생략 가능 |
| **next-translate** | `useTranslation()`  | 네임스페이스     | **필수**  | `useTranslation('common')` 필수            |
| **react-intl**     | `useIntl()`         | 없음             | -         | 네임스페이스 미지원                        |
| **LinguiJS**       | `useLingui()`       | 없음             | -         | `t` 매크로 사용                            |
| **typesafe-i18n**  | `L` 객체            | 없음             | -         | 타입 안전 객체 사용                        |
| **rosetta**        | 없음                | 없음             | -         | 직접 `i18n.t()` 호출                       |

### Locale 감지 및 설정 방식

| 라이브러리         | Locale 감지 방식                            | Locale 변경 방법                      |
| ------------------ | ------------------------------------------- | ------------------------------------- |
| **react-i18next**  | `i18next-browser-languagedetector` 플러그인 | `i18n.changeLanguage('ko')`           |
| **next-i18next**   | Next.js 라우팅 기반 (`/ko/page`)            | `router.push('/ko/page')`             |
| **next-intl**      | URL 경로 기반 (`/[locale]/page`)            | `Link href="/ko/page"`                |
| **next-translate** | Next.js 라우팅 기반                         | `router.push('/ko/page')`             |
| **react-intl**     | URL 쿼리 파라미터 (`?locale=ko`)            | `window.location.href = '?locale=ko'` |
| **LinguiJS**       | 런타임 상태                                 | `i18n.activate('ko')`                 |
| **typesafe-i18n**  | 런타임 상태                                 | `loadLocaleAsync('ko')`               |
| **rosetta**        | 런타임 상태                                 | `i18n.locale('ko')`                   |

### 예시 코드 비교

#### react-i18next

```jsx
// Locale: locales/{locale}/common.json
// 설정: i18n.js의 resources 객체
const { t } = useTranslation("common"); // 네임스페이스 선택
i18n.changeLanguage("ko"); // Locale 변경
```

#### next-intl

```tsx
// Locale: messages/{locale}.json
// 설정: i18n.ts의 locales 배열
const t = useTranslations("common"); // 네임스페이스 선택
// Locale은 URL 경로로 자동 감지: /ko/page
```

#### next-translate

```jsx
// Locale: locales/{locale}/common.json
// 설정: i18n.json의 locales 배열
const { t } = useTranslation("common"); // 네임스페이스 필수
// Locale은 Next.js 라우팅으로 자동 감지
```

#### react-intl

```jsx
// Locale: src/messages/{locale}.json
// 설정: IntlProvider의 locale prop
const intl = useIntl(); // 네임스페이스 없음
<IntlProvider locale="ko" messages={koMessages}>
```

## 라이브러리별 기능 비교

| 기능                  | i18next     | react-intl    | next-intl        | LinguiJS    | typesafe-i18n |
| --------------------- | ----------- | ------------- | ---------------- | ----------- | ------------- |
| **ICU 지원**          | 플러그인[2] | 네이티브[2]   | 네이티브[10]     | 네이티브    | 없음          |
| **TypeScript**        | ✓[5]        | ✓             | ✓ (자동생성)[13] | ✓           | ✓ (핵심)[18]  |
| **Server Components** | ✓           | ✓             | ✓ (최적화)[10]   | ✓           | ✓             |
| **번들 크기**         | ~9kb        | ~17kb         | 최적화 로딩      | ~3kb        | ~1kb[18]      |
| **네임스페이스**      | ✓           | 없음          | ✓                | ✓           | ✓             |
| **기본 Scanner**      | 여러 도구   | @formatjs/cli | 없음             | @lingui/cli | 없음          |

## 추천 사용 시나리오

**Next.js App Router 프로젝트**: **next-intl**이 가장 적합합니다. Server Components 최적화, 타입 안전성, 로컬라이즈된 라우팅을 모두 제공합니다[11][36].

**대규모 React 애플리케이션**: **react-i18next**를 권장합니다. 풍부한 플러그인 생태계와 네임스페이스 기반 코드 스플리팅이 가능합니다[37][2].

**ICU 표준 준수가 필요한 경우**: **react-intl** 또는 **LinguiJS**가 적합합니다. 다른 플랫폼과의 호환성이 중요할 때 선택합니다[2].

**번들 크기 최적화가 중요한 경우**: **next-translate**(~1kb), **typesafe-i18n**(~1kb), 또는 **rosetta**(298 bytes)를 고려합니다[18][16][24].

**완전한 타입 안전성이 필요한 경우**: **typesafe-i18n** 또는 **next-intl**(createMessagesDeclaration 사용)이 최선의 선택입니다[18][13].
