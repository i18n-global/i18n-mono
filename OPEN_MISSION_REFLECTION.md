# 우테코 오픈 미션 소감문

## 도전 배경 및 목표

### 왜 Rust 마이그레이션을 선택했는가?

이번 오픈 미션을 준비하면서 가장 고민했던 것은 "나에게 진정으로 도전이 되는 것이 무엇인가?"였습니다. 프리코스를 진행하면서 JavaScript와 TypeScript는 어느 정도 익숙해졌고, 웹 개발도 익숙한 영역이었습니다. 하지만 **익숙한 것에서 벗어나지 않으면 진정한 성장은 없다**는 생각이 들었습니다.

### 컴포트 존을 벗어나는 도전

Rust는 저에게 완전히 생소한 영역이었습니다. 시스템 프로그래밍 언어를 접해본 적이 없었고, 메모리 관리도 가비지 컬렉터에 의존했던 저에게 소유권(Ownership) 개념은 매우 낯설었습니다. 하지만 바로 이 점이 **컴포트 존을 벗어나는 도전**이 될 수 있다고 생각했습니다.

프리코스 기간 동안 `i18nexus-tools`를 개발했을 때는 개발 속도 향상을 위해 AI로만 초기 버전을 만들었습니다. 빠르게 프로토타입을 만들 수 있었지만, 실제 사용하면서 엣지 케이스가 계속 나타났고, 초기 기획과 다른 상황들이 발생했습니다. 그때마다 코드를 수정하는 것이 매우 힘들었고, **"코드를 작성하는 것"과 "유지보수 가능한 코드를 작성하는 것"의 차이**를 절실히 느꼈습니다.

### 선택의 배경: React 컴파일러 기여 경험

최근 React 컴파일러 이슈에 기여하면서 개발의 새로운 재미를 느꼈습니다. 단순히 프레임워크를 사용하는 것이 아니라, 프레임워크의 내부를 이해하고 개선하는 것이 얼마나 재미있는지 깨달았습니다. 이것이 **코어 개발**에 대한 관심으로 이어졌고, 자동화와 DX(Developer Experience) 향상에 빠지게 되었습니다.

우리 팀에서도 프론트엔드-백엔드 소통 문제를 해결하기 위해 Bruno 기반 API 명세를 자동으로 프론트엔드 쿼리와 쿼리키로 변환해 PR을 생성하는 도구를 만들고 있습니다.

**Bruno 기반 자동화 도구의 작동 방식:**

1. 백엔드 개발자가 Bruno 파일(API 명세)을 작성하고 리포지토리에 머지합니다.
2. GitHub Actions가 자동으로 트리거되어, Bruno 파일을 분석합니다.
3. 도구가 자동으로 프론트엔드에 필요한 쿼리와 쿼리키를 생성합니다 (React Query 기반).
4. 생성된 코드로 자동으로 PR을 만들어줍니다.
5. 프론트엔드 개발자는 그 PR을 머지하고, 새로운 PR을 만들어서 피처를 개발하면 됩니다.

**이 도구의 가치:**

기존에는 백엔드 개발자가 API를 만들면, 프론트엔드 개발자에게 "이런 API가 있어요"라고 알려주고, 프론트엔드 개발자가 직접 쿼리를 작성해야 했습니다. 이 과정에서:

- API 명세를 읽고 이해하는 시간
- 쿼리를 작성하는 시간
- 타입을 정의하는 시간
- 쿼리키를 정의하는 시간

이 모든 것이 자동화되면, 프론트엔드 개발자는 **비즈니스 로직에만 집중**할 수 있습니다. 단순 반복 작업이 줄어들고, 프론트엔드-백엔드 소통 비용도 줄어듭니다. 이것이 바로 **자동화가 DX를 향상**시키는 방법입니다.

이 도구도 AI로 초안을 잡았지만, 기능을 추가하려면 결국 코드를 깔끔하게 정리하는 것이 필요했습니다. 분리하다 보니 테스트 코드의 중요성을 또한 느꼈고, 특히 AI에게 수정을 요청할 때에도 테스트 코드가 있어야 안전하게 작동함을 확인할 수 있었습니다.

이런 경험들을 통해 느낀 것은, 단순히 API 명세와 스펙을 공유하는 것보다 **도메인적으로 중요한 것이 무엇인지 생각하는 것**이 더 중요하다는 점이었습니다. 그리고 이러한 개발자 경험을 향상시키는 도구를 만들기 위해서는, 단순히 표면적인 지식이 아니라 **깊은 이해**가 필요하다는 것을 깨달았습니다.

### 왜 Rust인가?

이런 배경에서 Rust로 마이그레이션하는 도전을 선택했습니다. Rust를 선택한 이유는:

- **성능**: 컴파일 타임 최적화와 메모리 안전성. 대규모 코드베이스를 처리하는 도구를 만들기 위해서는 성능이 중요했습니다.
- **타입 안전성**: 컴파일 시점에 오류를 잡을 수 있는 강력한 타입 시스템. TypeScript보다 훨씬 엄격한 타입 시스템을 경험하고 싶었습니다.
- **학습 가치**: 시스템 프로그래밍 언어를 배우며 더 깊은 이해를 얻고 싶었습니다. JavaScript나 TypeScript에서는 경험할 수 없는 메모리 관리와 소유권 개념을 배우고 싶었습니다.
- **코어 개발의 재미**: React 컴파일러 기여 경험을 통해 느낀 코어 개발의 즐거움을 더 깊이 경험하고 싶었습니다.

### 도전의 난이도

이 도전이 저에게 얼마나 어려웠는지 솔직히 말하면, **Rust를 처음 접했고**, **시스템 프로그래밍 경험이 전혀 없었으며**, **AST 조작도 처음**이었습니다. SWC라는 Rust 기반 컴파일러를 사용해야 했는데, 문서도 많지 않고 예제도 찾기 어려웠습니다. 하지만 바로 이 점이 **진정한 도전**이라고 생각했습니다.

2주라는 시간에 완성하기는 어렵다는 것을 알았지만, **"완성도보다 과정"**이라는 오픈 미션의 가치를 믿고 도전했습니다. 실패하더라도 그 과정에서 배우고 성장한다면, 그것이 진정한 가치라고 생각했습니다.

## 진행 과정

### 1단계: 리팩토링 (기반 작업)

먼저 기존 코드베이스를 정리했습니다. AI로만 작성된 코드는 모듈 간 의존성이 불명확하고, 테스트하기 어려운 구조였습니다. 특히 엣지 케이스가 나타날 때마다 코드를 수정하는 것이 매우 어려웠습니다.

**구체적인 문제 상황:**

예를 들어, 초기 버전에서는 `translation-wrapper.ts` 파일 하나에 모든 로직이 섞여 있었습니다. AST 변환 로직, import 관리, 파일 처리, 성능 모니터링이 모두 한 파일에 있었고, 각 기능이 서로 강하게 결합되어 있었습니다. 새로운 기능을 추가하려면 이 거대한 파일을 수정해야 했고, 한 곳을 수정하면 다른 곳에 영향을 미치는 경우가 많았습니다.

특히 엣지 케이스가 발생했을 때, 예를 들어 특정 JSX 패턴에서 변환이 제대로 되지 않는 경우, 어디서 문제가 발생했는지 찾는 것부터 어려웠습니다. AST 변환 로직인지, import 관리 로직인지, 아니면 파일 처리 로직인지 구분하기 어려웠습니다.

**리팩토링 과정:**

1. **모듈 분리**: `ast-helpers.ts`, `ast-transformers.ts`, `import-manager.ts`, `translation-wrapper.ts`로 기능별로 분리했습니다. 각 모듈이 하나의 명확한 책임을 가지도록 했습니다.

2. **의존성 명확화**: 각 모듈이 어떤 모듈에 의존하는지 명확히 했습니다. 예를 들어, `ast-transformers`는 `ast-helpers`와 `constants`에만 의존하도록 했습니다.

3. **인터페이스 정의**: 각 모듈의 공개 API를 명확히 정의했습니다. 내부 구현은 숨기고, 외부에서 사용할 수 있는 함수만 노출했습니다.

**배운 점:**

- **코드 구조의 중요성**: 리팩토링을 통해 각 모듈의 책임을 명확히 하고, 테스트 가능한 구조로 만들었습니다. "작동하는 코드"와 "유지보수 가능한 코드"의 차이를 직접 경험했습니다. 리팩토링 후에는 새로운 기능을 추가할 때 어느 모듈을 수정해야 하는지 명확해졌습니다.

- **AI 코드의 한계**: AI가 생성한 코드는 빠르게 프로토타입을 만들 수 있지만, 실제 프로덕션에서 발생하는 엣지 케이스를 대응하기 어렵습니다. 초기 기획과 다른 상황이 발생했을 때 수정이 매우 힘들었습니다. AI는 일반적인 케이스는 잘 처리하지만, 예외 상황이나 복잡한 상호작용은 놓치기 쉽습니다.

- **코드 정리의 필요성**: 기능을 추가하려면 먼저 코드를 깔끔하게 정리해야 한다는 것을 배웠습니다. 정리되지 않은 코드베이스에서는 새로운 기능을 안전하게 추가하기 어렵습니다. 리팩토링을 통해 코드베이스가 더 안정적이고 확장 가능해졌습니다.

### 2단계: 테스트 코드 추가

리팩토링 후 안전성을 확보하기 위해 테스트 코드를 추가했습니다. 특히 AI에게 코드 수정을 요청할 때도 테스트 코드가 있어야 안전하게 작동함을 확인할 수 있다는 것을 깨달았습니다.

**테스트 코드 작성 과정:**

각 모듈별로 테스트 파일을 만들었습니다. `ast-helpers.test.ts`, `ast-transformers.test.ts`, `import-manager.test.ts`, `translation-wrapper.test.ts` 등입니다. TypeScript 버전의 테스트를 Rust로 포팅하면서, 테스트 코드가 얼마나 중요한지 깨달았습니다.

**구체적인 경험:**

예를 들어, `has_ignore_comment` 함수를 수정할 때, 테스트 코드가 없었다면 기존 동작이 깨졌는지 확인하기 어려웠을 것입니다. 하지만 테스트 코드가 있어서, 함수를 수정한 후 테스트를 실행하면 즉시 문제를 발견할 수 있었습니다.

특히 AI에게 코드 수정을 요청할 때, 테스트 코드가 있으면 AI가 생성한 코드가 올바르게 작동하는지 확인할 수 있었습니다. AI가 생성한 코드를 바로 프로덕션에 적용하기 전에, 테스트를 실행해서 검증할 수 있었습니다. 테스트 없이는 AI가 만든 코드를 신뢰하기 어려웠습니다.

**배운 점:**

- **테스트 코드의 안전망 역할**: 테스트 코드가 리팩토링의 안전망이 된다는 것을 직접 경험했습니다. 코드를 수정할 때 테스트가 있으면 안심하고 변경할 수 있었습니다. 예를 들어, 모듈을 분리할 때 기존 동작이 유지되는지 테스트로 확인할 수 있었습니다.

- **AI와의 협업에서의 테스트**: AI에게 코드 수정을 요청할 때, 테스트 코드가 있으면 AI가 생성한 코드가 올바르게 작동하는지 확인할 수 있었습니다. 테스트 없이는 AI가 만든 코드를 신뢰하기 어려웠습니다. AI는 때때로 엣지 케이스를 놓치거나, 기존 동작을 깨뜨리는 경우가 있는데, 테스트 코드가 이를 잡아줍니다.

- **TDD의 가치**: 테스트를 먼저 작성하면(TDD) 더 나은 설계가 나온다는 것을 배웠습니다. 코드 변경에 대한 두려움이 줄어들고, 더 적극적으로 개선할 수 있게 되었습니다. Rust 포팅을 할 때도, 먼저 테스트 코드를 작성하고 나서 구현을 했는데, 이것이 더 명확한 설계로 이어졌습니다.

- **Node 기반 테스트의 도움**: 우테코에서 Node 기반으로 테스트 코드를 작성하는 것이 매우 도움이 되었습니다. 실제 프로젝트에서도 바로 적용할 수 있는 패턴들을 배웠습니다. Jest를 사용한 테스트 작성 방법, mocking, fixture 사용 등 실무에서 바로 쓸 수 있는 지식들을 얻었습니다.

### 3단계: 기획 수정

원래 계획은 매우 복잡했습니다. 하지만 실제 구현을 시작하면서 현실적인 제약을 깨달았습니다. 특히 API 명세와 스펙을 자주 공유하는데 시간을 쏟기보다는, 도메인적으로 중요한 것이 무엇인지 생각하는 것이 더 중요하다는 것을 깨달았습니다.

**배운 점:**

- **실행 가능한 계획의 중요성**: 완벽한 계획보다는 실행 가능한 계획이 중요하다는 것을 배웠습니다. 복잡한 기획은 구현을 어렵게 만들 뿐입니다.
- **도메인 중심 사고**: API 명세와 스펙을 공유하는 것도 중요하지만, 비즈니스적으로 중요한 것이 무엇인지 생각하는 것이 더 중요합니다.

**구체적인 예시:**

기존 방식에서는 백엔드 개발자와 프론트엔드 개발자가 자주 소통해야 했습니다:

- "이 API 엔드포인트가 뭐죠?"
- "이 응답 타입이 어떻게 되죠?"
- "이 쿼리키는 어떻게 정의해야 하죠?"

이런 소통 자체가 나쁜 것은 아니지만, **비즈니스 로직과 관련 없는 기술적 소통**에 시간을 많이 쏟게 됩니다. 정작 중요한 것은:

- "이 기능이 사용자에게 어떤 가치를 주는가?"
- "이 UI/UX가 사용자에게 직관적인가?"
- "이 비즈니스 로직이 올바른가?"

우리 팀의 Bruno 기반 자동화 도구는 기술적 소통을 자동화해서, **비즈니스 로직에 집중할 수 있게** 해줍니다. 프론트엔드 개발자는 API 명세를 읽고 쿼리를 작성하는 시간을 줄이고, 대신 "이 데이터를 어떻게 보여줄까?" "사용자 경험을 어떻게 개선할까?"에 집중할 수 있습니다.

이것이 **도메인 중심 사고**입니다. 기술적인 세부사항보다, 비즈니스적으로 중요한 것이 무엇인지 생각하는 것입니다.

- **단순화의 가치**: 기획을 단순화하면서도 핵심 가치를 유지하는 방법을 배웠습니다. "완벽한 것보다 완성된 것"이 더 가치 있다는 것을 깨달았습니다.

### 4단계: Rust 마이그레이션 도전

이것이 가장 큰 도전이었습니다. Rust를 처음 접했고, TypeScript와는 완전히 다른 패러다임이었습니다.

#### Rust 언어 자체의 학습

Rust를 처음 접했을 때 가장 충격적이었던 것은 컴파일러가 매우 엄격하다는 것이었습니다. TypeScript는 타입 에러가 있어도 일단 실행은 되지만, Rust는 컴파일이 안 되면 실행 자체가 불가능합니다.

**소유권(Ownership) 개념:**

처음에는 소유권 개념이 매우 어려웠습니다. 예를 들어, 함수에 값을 전달할 때마다 소유권이 이동하고, 이후에는 그 값을 사용할 수 없게 됩니다. 이것이 처음에는 매우 불편했지만, 메모리 안전성을 보장하는 Rust의 핵심 철학이라는 것을 이해하게 되었습니다.

```rust
// 처음에는 이런 에러가 계속 발생했습니다
fn process_string(s: String) {
    // s를 사용
}

let my_string = String::from("hello");
process_string(my_string);
// 에러: my_string은 이미 이동되었습니다
// println!("{}", my_string); // 컴파일 에러!
```

이런 에러를 해결하면서, 참조(`&`), 가변 참조(`&mut`), 소유권 이동의 개념을 이해하게 되었습니다. 메모리 관리를 직접 해야 한다는 것이 부담이었지만, 동시에 더 깊은 이해를 얻을 수 있었습니다.

**타입 시스템:**

TypeScript도 타입이 있지만, Rust의 타입 시스템은 훨씬 엄격하고 강력했습니다. 특히 `Option<T>`와 `Result<T, E>` 타입을 통해 에러 처리를 명시적으로 해야 한다는 것을 배웠습니다.

```rust
// TypeScript에서는 null 체크를 깜빡할 수 있지만
// Rust에서는 Option을 반환하면 반드시 처리해야 합니다
fn get_value() -> Option<String> {
    Some("hello".to_string())
}

// match나 if let으로 반드시 처리해야 함
match get_value() {
    Some(value) => println!("{}", value),
    None => println!("No value"),
}
```

이것이 더 안전한 코드를 만든다는 것을 배웠습니다. 컴파일 타임에 모든 에러 케이스를 처리하도록 강제하기 때문에, 런타임 에러가 줄어듭니다.

**패턴 매칭:**

`match` 표현식의 강력함을 경험했습니다. 모든 경우를 처리해야 한다는 것이 안전성을 보장한다는 것을 깨달았습니다. 예를 들어, enum의 모든 variant를 처리하지 않으면 컴파일 에러가 발생합니다.

**배운 점:**

- **소유권(Ownership) 개념**: 메모리 관리가 컴파일 타임에 이루어진다는 것이 신기했습니다. 처음에는 컴파일러 에러가 많았지만, 이를 해결하면서 메모리 안전성에 대한 이해가 깊어졌습니다. 메모리 누수나 use-after-free 같은 버그를 컴파일 타임에 방지할 수 있다는 것이 Rust의 가장 큰 장점입니다.

- **타입 시스템**: TypeScript도 타입이 있지만, Rust의 타입 시스템은 훨씬 엄격하고 강력했습니다. `Option`, `Result` 같은 타입을 통해 에러 처리를 명시적으로 해야 한다는 것을 배웠습니다. 이것이 더 안전하고 예측 가능한 코드를 만듭니다.

- **패턴 매칭**: `match` 표현식의 강력함을 경험했습니다. 모든 경우를 처리해야 한다는 것이 안전성을 보장한다는 것을 깨달았습니다. 이것이 런타임 에러를 줄이는 데 큰 도움이 됩니다.

#### SWC AST 구조 이해

TypeScript 코드를 Rust로 변환하려면 AST(Abstract Syntax Tree)를 조작해야 했습니다. SWC라는 Rust 기반 컴파일러를 사용했습니다. 이것이 가장 어려웠던 부분 중 하나였습니다.

**AST의 구조 이해:**

처음에는 AST가 무엇인지도 잘 몰랐습니다. 코드가 어떻게 트리 구조로 표현되는지 이해하는데 시간이 걸렸습니다. 예를 들어, `const text = "안녕하세요"`라는 코드는 다음과 같은 AST 노드로 표현됩니다:

- `VariableDeclarator` - 변수 선언
  - `BindingIdent` - 변수 이름 (`text`)
  - `StringLiteral` - 문자열 리터럴 (`"안녕하세요"`)

이런 구조를 이해하고, 각 노드를 순회하고 수정하는 방법을 배웠습니다.

**VisitMut 패턴:**

SWC의 방문자 패턴을 통해 AST를 순회하고 수정하는 방법을 배웠습니다. `VisitMut` trait를 구현하고, `visit_mut_expr`, `visit_mut_fn_decl` 같은 메서드를 오버라이드해서 원하는 노드를 찾고 수정할 수 있습니다.

```rust
impl VisitMut for TranslationTransformer {
    fn visit_mut_expr(&mut self, expr: &mut Expr) {
        // StringLiteral을 t() 호출로 교체
        if let Expr::Lit(Lit::Str(str_lit)) = expr {
            // 변환 로직
        }
        expr.visit_mut_children_with(self);
    }
}
```

이런 패턴을 사용해서 AST를 순회하고 수정하는 방법을 익혔습니다. 처음에는 트리 구조를 다루는 것이 어려웠지만, 점차 익숙해졌습니다.

**Wtf8Atom의 어려움:**

가장 큰 어려움 중 하나는 `Wtf8Atom`이라는 Rust의 특수 문자열 타입이었습니다. SWC는 내부적으로 `Wtf8Atom`을 사용하는데, 이것을 일반 `String`이나 `&str`로 변환하는 것이 생각보다 어려웠습니다.

```rust
// 이런 코드를 작성했지만
let value: &str = &str_lit.value; // 에러: Wtf8Atom은 &str로 변환 불가

// to_string()도 작동하지 않았습니다
let value = str_lit.value.to_string(); // 에러: Wtf8Atom은 ToString을 구현하지 않음
```

결국 임시로 소스코드를 직접 검사하는 방식으로 우회했습니다. 이것이 "완벽하지 않아도 작동하는 것"의 중요성을 보여주었습니다. 완벽한 해결책을 찾기 위해 시간을 낭비하기보다는, 작동하는 해결책을 먼저 구현하고 나중에 개선하는 것이 더 나은 접근이었습니다.

**배운 점:**

- **AST의 구조**: 코드가 어떻게 트리 구조로 표현되는지 이해했습니다. 각 노드가 어떤 정보를 담고 있는지, 어떻게 순회하고 수정하는지 배웠습니다. 이것이 컴파일러나 코드 변환 도구를 만드는 기초가 됩니다.

- **VisitMut 패턴**: SWC의 방문자 패턴을 통해 AST를 순회하고 수정하는 방법을 배웠습니다. `visit_mut_expr`, `visit_mut_fn_decl` 같은 메서드를 구현하면서 트리 구조를 다루는 방법을 익혔습니다. 이것이 함수형 프로그래밍의 패턴과도 유사하다는 것을 깨달았습니다.

- **Wtf8Atom의 어려움**: Rust의 문자열 타입이 복잡하다는 것을 경험했습니다. `Wtf8Atom`을 일반 문자열로 변환하는 것이 생각보다 어려웠고, 임시로 소스코드를 직접 검사하는 방식으로 우회했습니다. 이것이 "완벽하지 않아도 작동하는 것"의 중요성을 보여주었습니다. 실용적인 해결책이 때로는 이론적으로 완벽한 해결책보다 더 가치 있을 수 있습니다.

#### TypeScript와 Rust의 차이

**배운 점:**

- **동적 vs 정적**: TypeScript는 런타임에 많은 것을 결정하지만, Rust는 컴파일 타임에 가능한 한 많은 것을 결정합니다. 이 차이 때문에 코드 작성 방식이 완전히 달라졌습니다.
- **에러 처리**: TypeScript는 `try-catch`로 에러를 처리하지만, Rust는 `Result<T, E>` 타입으로 에러를 명시적으로 처리해야 합니다. 이것이 더 안전한 코드를 만든다는 것을 배웠습니다.
- **타입 추론**: Rust의 타입 추론이 매우 강력하다는 것을 경험했습니다. 많은 경우 타입을 명시하지 않아도 컴파일러가 추론해줍니다.

## 어려움과 극복 과정

### 1. 컴파일 에러의 연속

처음에는 컴파일 에러가 너무 많아서 좌절했습니다. TypeScript에서는 타입 에러가 있어도 일단 실행은 되지만, Rust는 컴파일이 안 되면 실행 자체가 불가능합니다. 처음에는 이것이 매우 불편했지만, 하나씩 해결해나가면서 Rust의 철학을 이해하게 되었습니다.

**구체적인 에러 경험:**

예를 들어, `Ident` 구조체를 만들 때 필수 필드를 빠뜨려서 에러가 발생했습니다:

```rust
// 에러: missing field `ctxt`
let ident = Ident {
    span: DUMMY_SP,
    sym: "t".into(),
    optional: false,
    // ctxt 필드가 없어서 에러
};
```

또는 `PropName::Ident`에 잘못된 타입을 전달해서 에러가 발생했습니다:

```rust
// 에러: expected `IdentName`, found `Ident`
key: PropName::Ident(Ident { ... })
```

이런 에러들을 하나씩 해결하면서, Rust의 타입 시스템이 얼마나 엄격한지, 그리고 이것이 얼마나 안전한 코드를 만드는지 깨달았습니다.

**배운 점:**

- **컴파일러의 친절함**: 컴파일러가 친절하게 에러를 알려준다는 것을 배웠습니다. 에러 메시지를 자세히 읽으면 해결 방법을 찾을 수 있었습니다. Rust 컴파일러는 단순히 "에러가 있다"고만 알려주는 것이 아니라, "어디서 문제가 발생했는지", "어떻게 수정해야 하는지"까지 제안해줍니다.

- **안전성의 가치**: "컴파일이 안 되면 실행도 안 된다"는 것이 오히려 안전하다는 것을 깨달았습니다. 런타임에 발생할 수 있는 에러를 컴파일 타임에 미리 잡을 수 있다는 것이 Rust의 가장 큰 장점입니다. 처음에는 불편했지만, 나중에는 이것이 얼마나 큰 가치인지 깨달았습니다.

### 2. 메모리 관리의 어려움

소유권 개념이 처음에는 매우 어려웠습니다. `Box`, `Rc`, `Arc` 같은 스마트 포인터를 언제 사용해야 하는지 고민이 많았습니다. TypeScript나 JavaScript에서는 메모리 관리를 신경 쓸 필요가 없었는데, Rust에서는 메모리 관리를 직접 해야 했습니다.

**구체적인 어려움:**

예를 들어, AST 노드를 생성할 때 `Box`를 사용해야 하는 경우가 많았습니다:

```rust
// Box를 사용해야 하는 경우
let expr = Box::new(Expr::Call(CallExpr { ... }));

// 또는 함수 파라미터로 전달할 때
fn process_expr(expr: Box<Expr>) { ... }
```

처음에는 왜 `Box`를 사용해야 하는지 이해하기 어려웠습니다. 하지만 Rust의 소유권 시스템을 이해하면서, 힙에 할당된 데이터를 다루기 위해서는 `Box`가 필요하다는 것을 배웠습니다.

또한, 여러 곳에서 같은 데이터를 참조해야 하는 경우 `Rc`나 `Arc`를 사용해야 했는데, 이것도 처음에는 어려웠습니다. 언제 `Rc`를 사용하고 언제 `Arc`를 사용해야 하는지, 언제 `Box`를 사용해야 하는지 구분하는 것이 어려웠습니다.

**배운 점:**

- **메모리 관리의 깊이**: 메모리 관리를 직접 해야 한다는 것이 부담이었지만, 동시에 더 깊은 이해를 얻을 수 있었습니다. JavaScript나 TypeScript에서는 가비지 컬렉터가 메모리를 관리해주지만, Rust에서는 개발자가 직접 메모리를 관리해야 합니다. 이것이 처음에는 부담이었지만, 나중에는 메모리가 어떻게 관리되는지 더 깊이 이해할 수 있게 되었습니다.

- **컴파일러의 보장**: 컴파일러가 메모리 안전성을 보장해준다는 것이 얼마나 큰 가치인지 깨달았습니다. 메모리 누수나 use-after-free 같은 버그를 컴파일 타임에 방지할 수 있다는 것이 Rust의 가장 큰 장점입니다. 이것이 C나 C++ 같은 언어에서 발생하는 메모리 관련 버그를 방지할 수 있게 해줍니다.

### 3. 시간 부족과 현실적 판단

2주라는 시간은 Rust 초보에게 완전한 마이그레이션을 하기에는 턱없이 부족했습니다. 하지만 이것이 오히려 **스텝 바이 스텝**으로 난이도를 조절하며 도전하는 계기가 되었습니다.

**처음 계획:**

- 1주차: Rust 기초 학습 + TypeScript 코드 분석
- 2주차: 핵심 로직 포팅 + 테스트 작성
- 목표: 완전한 마이그레이션

**현실:**

- 1일차: Rust 문법을 배우는데도 하루가 걸렸습니다. 소유권 개념을 이해하는 것만으로도 머리가 복잡했습니다.
- 2~3일차: SWC 문서를 읽고 예제를 따라하는데 2일이 걸렸습니다. AST 구조를 이해하는 것이 생각보다 어려웠습니다.
- 4~7일차: 기본 파서를 구현하고 컴파일 에러를 해결하는데 4일이 걸렸습니다. 매일 수십 개의 컴파일 에러와 싸웠습니다.
- 8~10일차: AST 변환 로직을 구현했지만, `Wtf8Atom` 문자열 타입 변환 문제로 막혔습니다. 3일을 고민했지만 해결하지 못하고, 임시 우회 방법을 사용했습니다.
- 11~14일차: 함수 탐색 로직을 추가하고, `useTranslation` 훅을 AST 노드로 생성하는 로직을 구현했습니다. 테스트를 작성하고 실행하는데도 많은 시간이 걸렸습니다.

**현실적 판단:**

2주가 지나면서, 완전한 마이그레이션은 불가능하다는 것을 인정해야 했습니다. 처음에는 좌절감이 들었지만, **"포기하지 않는 이상 실패는 없다"**는 오픈 미션의 가치를 떠올렸습니다. 완성도보다는 과정이 중요하다는 것을, 그리고 이 과정에서 배운 것이 더 가치 있다는 것을 깨달았습니다.

약 40% 정도 진행했지만, 이 과정에서:

- Rust 언어의 기초를 배웠습니다
- 소유권과 메모리 관리를 이해했습니다
- AST 조작의 기초를 익혔습니다
- 컴파일 타임 타입 안전성의 가치를 경험했습니다
- 가장 중요하게, **내가 얼마나 많은 것을 모르는지** 알게 되었습니다

**배운 점:**

- **"완성도보다 과정"의 진정한 의미**: 오픈 미션의 가치를 이해하게 되었습니다. 완벽한 결과물을 만드는 것이 아니라, 도전하고 배우는 과정이 더 중요하다는 것을 직접 경험했습니다.

- **현실적 판단의 중요성**: 현실적으로 판단하고 마무리하는 것도 중요한 능력이라는 것을 배웠습니다. 완벽주의에 빠져 아무것도 제출하지 못하는 것보다, 현재 상태를 인정하고 그 과정을 정리하는 것이 더 가치 있습니다.

- **스텝 바이 스텝의 가치**: 처음부터 거창한 목표를 세우기보다는, 현재 수준에서 조금씩 난이도를 높여가는 것이 더 효과적이라는 것을 배웠습니다. 약 40% 진행했지만, 그 과정에서 배운 것이 더 중요하다는 것을 깨달았습니다.

## 실패했지만 의미 있었던 시도들

오픈 미션을 진행하면서 많은 시도들이 실패로 끝났지만, 그 과정에서 배운 것들이 더 가치 있었습니다.

### 1. Wtf8Atom 문자열 변환 도전

가장 오래 고민했던 부분은 `Wtf8Atom` 문자열 타입을 일반 `String`이나 `&str`로 변환하는 것이었습니다. SWC는 내부적으로 `Wtf8Atom`을 사용하는데, 이것을 변환하는 표준 방법을 찾지 못했습니다.

**시도 1: to_string() 사용**

```rust
let value = str_lit.value.to_string(); // 에러: Wtf8Atom은 ToString을 구현하지 않음
```

실패했습니다. `Wtf8Atom`은 `ToString` trait를 구현하지 않았습니다.

**시도 2: as_ref() 사용**

```rust
let value: &str = str_lit.value.as_ref(); // 에러: Wtf8Atom은 AsRef<str>를 구현하지 않음
```

이것도 실패했습니다.

**시도 3: 문서 읽기**
SWC 문서를 읽고, GitHub 이슈를 검색하고, Stack Overflow를 찾아봤지만, 명확한 해답을 찾지 못했습니다. 3일을 고민했습니다.

**최종 해결책: 우회**
결국 소스코드를 직접 검사하는 방식으로 우회했습니다. 완벽한 해결책은 아니지만, 작동하는 해결책이었습니다.

**배운 점:**

- **완벽함보다 실용성**: 완벽한 해결책을 찾기 위해 시간을 낭비하기보다는, 작동하는 해결책을 먼저 구현하고 나중에 개선하는 것이 더 나은 접근이었습니다.
- **문제 해결 능력**: 막막한 상황에서도 다양한 방법을 시도하고, 우회 방법을 찾는 능력을 키웠습니다.

### 2. VisitMut 패턴의 무한 재귀 문제

AST를 변환할 때, `visit_mut_str`을 사용해서 문자열을 직접 수정하려고 했습니다. 하지만 문자열을 `t()` 호출로 교체하면, 부모 노드를 교체해야 하는데 이것이 어려웠습니다.

**시도 1: visit_mut_str에서 직접 교체**

```rust
fn visit_mut_str(&mut self, str_lit: &mut Str) {
    // 어떻게 부모 노드를 교체하지?
}
```

실패했습니다. `visit_mut_str`에서는 부모 노드에 접근할 수 없었습니다.

**시도 2: visit_mut_expr에서 교체**

```rust
fn visit_mut_expr(&mut self, expr: &mut Expr) {
    if let Expr::Lit(Lit::Str(str_lit)) = expr {
        // 여기서 expr을 교체
    }
    expr.visit_mut_children_with(self); // 자식 방문
}
```

이것은 작동했지만, 무한 재귀 문제가 발생했습니다. `t()` 호출로 교체한 후에도 자식을 방문해서, 다시 변환하려고 시도했습니다.

**최종 해결책: 변환 후 자식 방문 건너뛰기**

```rust
fn visit_mut_expr(&mut self, expr: &mut Expr) {
    if let Expr::Lit(Lit::Str(str_lit)) = expr {
        *expr = self.create_t_call(str_lit);
        return; // 자식 방문 건너뛰기
    }
    expr.visit_mut_children_with(self);
}
```

**배운 점:**

- **방문자 패턴의 이해**: 방문자 패턴에서 자식 노드 방문 순서와 타이밍이 중요하다는 것을 배웠습니다.
- **디버깅 능력**: 스택 오버플로우 에러를 분석하고, 무한 재귀의 원인을 찾아내는 능력을 키웠습니다.

### 3. PropName::Ident 타입 불일치

`useTranslation` 훅을 AST 노드로 생성할 때, `PropName::Ident`에 잘못된 타입을 전달해서 에러가 발생했습니다.

**시도 1: Ident 사용**

```rust
key: PropName::Ident(Ident { ... })
// 에러: expected `IdentName`, found `Ident`
```

**시도 2: 문서 확인**
SWC의 타입 정의를 확인해보니, `PropName::Ident`는 `IdentName`을 받아야 했습니다. `Ident`와 `IdentName`이 다른 타입이라는 것을 처음 알았습니다.

**최종 해결책:**

```rust
key: PropName::Ident(IdentName {
    sym: "t".into(),
    span: DUMMY_SP,
})
```

**배운 점:**

- **타입 시스템의 엄격함**: Rust의 타입 시스템이 얼마나 엄격한지, 그리고 이것이 얼마나 안전한 코드를 만드는지 깨달았습니다.
- **문서 읽기의 중요성**: 에러 메시지를 자세히 읽고, 타입 정의를 확인하는 습관을 키웠습니다.

## 가장 오래 고민했던 부분

### 1. 소유권 개념 이해 (3일)

Rust를 처음 배울 때 가장 오래 고민한 것은 소유권 개념이었습니다. 함수에 값을 전달하면 소유권이 이동하고, 이후에는 그 값을 사용할 수 없다는 것이 처음에는 이해되지 않았습니다.

```rust
let my_string = String::from("hello");
process_string(my_string);
// 에러: my_string은 이미 이동되었습니다
println!("{}", my_string); // 컴파일 에러!
```

TypeScript에서는 이런 개념이 없었기 때문에, 왜 이렇게 복잡하게 만들었는지 이해하지 못했습니다. 하지만 메모리 안전성을 보장하기 위한 Rust의 철학을 이해하면서, 점차 받아들이게 되었습니다.

**깨달음:**

- 메모리 관리를 직접 해야 한다는 것이 부담이지만, 동시에 더 깊은 이해를 얻을 수 있습니다.
- 컴파일 타임에 메모리 안전성을 보장하는 것이 런타임 에러를 줄이는 데 얼마나 큰 가치인지 깨달았습니다.

### 2. AST 구조 이해 (4일)

AST(Abstract Syntax Tree)가 무엇인지 이해하는데 오랜 시간이 걸렸습니다. 코드가 어떻게 트리 구조로 표현되는지, 각 노드가 어떤 정보를 담고 있는지, 어떻게 순회하고 수정하는지 배우는 과정이 쉽지 않았습니다.

특히 `VariableDeclarator`, `BindingIdent`, `StringLiteral` 같은 노드 타입들이 어떻게 연결되어 있는지 이해하는 것이 어려웠습니다. SWC 문서를 읽고, 예제를 따라하고, 직접 코드를 작성하면서 점차 이해하게 되었습니다.

**깨달음:**

- 컴파일러나 코드 변환 도구를 만드는 것이 얼마나 어려운지 깨달았습니다.
- AST를 이해하면, 코드를 더 깊이 이해할 수 있고, 더 나은 도구를 만들 수 있다는 것을 배웠습니다.

### 3. Wtf8Atom 문자열 변환 (3일)

앞서 언급했듯이, `Wtf8Atom` 문자열 타입을 변환하는 것이 가장 오래 고민한 문제 중 하나였습니다. 3일을 고민했지만 완벽한 해결책을 찾지 못하고, 우회 방법을 사용했습니다.

**깨달음:**

- 완벽한 해결책을 찾지 못해도, 작동하는 해결책을 찾는 것이 더 중요합니다.
- 실용적인 접근이 때로는 이론적으로 완벽한 해결책보다 더 가치 있을 수 있습니다.

## 가장 큰 배운 점

### 1. 모듈 시스템에 대한 이해 부족

이번 경험을 통해 가장 크게 느낀 것은 내가 모듈 시스템에 대한 이해가 부족하다는 것이었습니다. 이것이 가장 큰 배움이었고, 앞으로의 학습 방향을 결정하는 중요한 깨달음이었습니다.

**표면적 학습의 한계:**

React, Next.js를 사용할 때도 내부 동작 원리를 모른 채 메서드만 공부해서 쓰고 있었습니다. 예를 들어, `useState`가 어떻게 작동하는지, React의 렌더링 사이클이 어떻게 돌아가는지, Next.js의 라우팅이 어떻게 구현되어 있는지 몰랐습니다. "이렇게 하면 작동한다"는 것을 알았지만, "왜 이렇게 작동하는지"는 몰랐습니다.

이것이 문제가 된 것은, 복잡한 상황에서 문제를 해결할 때였습니다. 예를 들어, React 컴포넌트가 예상대로 렌더링되지 않을 때, 내부 동작 원리를 모르면 문제를 찾기 어려웠습니다. 단순히 "이렇게 하면 작동한다"는 지식만으로는 한계가 있었습니다.

**모듈의 본질:**

모듈 시스템에 대한 이해도 없이 모듈을 만들려고 했습니다. "모듈"이라는 단어로 각 모듈을 테스트한다거나, 특정 패턴을 적용하려고 했지만, 모듈의 본질을 이해하지 못한 채 사용하고 있었습니다.

**구체적인 문제 상황:**

예를 들어, 초기에는 다음과 같은 고민들을 했습니다:

- "모듈별로 테스트를 작성해야 하나?"
- "각 모듈에 특정 디자인 패턴(Factory, Strategy 등)을 적용해야 하나?"
- "모듈을 어떻게 나눠야 하나? 파일 개수는?"
- "모듈 간 의존성은 어떻게 관리해야 하나?"

하지만 이런 질문들을 할 때, **모듈이 무엇인지** 제대로 이해하지 못했습니다. 단순히 "모듈은 파일을 나누는 것"이라고 생각했고, "테스트는 모듈별로 작성하는 것"이라고 피상적으로 이해했습니다.

**깨달음:**

리팩토링을 하면서, 모듈의 본질은 다음과 같다는 것을 배웠습니다:

1. **관심사의 분리 (Separation of Concerns)**: 각 모듈은 하나의 명확한 책임을 가져야 합니다. `ast-helpers`는 AST 분석만, `ast-transformers`는 AST 변환만, `import-manager`는 import 관리만 담당해야 합니다. 하나의 모듈에 여러 책임이 섞이면 유지보수가 어려워집니다.

2. **의존성 관리**: 각 모듈이 다른 모듈에 최소한으로 의존해야 합니다. 순환 의존성이 생기면 안 되고, 명확한 의존성 방향이 있어야 합니다. 예를 들어, `ast-transformers`는 `ast-helpers`에 의존하지만, 그 반대는 안 됩니다.

3. **인터페이스와 구현 분리**: 모듈의 공개 API(interface)와 내부 구현(implementation)을 분리해야 합니다. 외부에서는 공개 API만 사용하고, 내부 구현은 숨겨야 합니다. 이렇게 하면 내부 구현을 변경해도 외부에 영향을 주지 않습니다.

4. **테스트 가능성**: 모듈이 명확한 책임을 가지고 있으면, 테스트하기도 쉽습니다. 단일 책임 원칙을 따르면 자연스럽게 테스트 가능한 코드가 됩니다.

**"너무나도 많은 생각"의 의미:**

초기에는 "모듈"이라는 단어에 너무 많은 의미를 부여했습니다. "모듈은 이렇게 설계해야 하고, 저렇게 테스트해야 하고, 이런 패턴을 적용해야 하고..." 이런 생각들이 머릿속을 복잡하게 만들었습니다.

하지만 본질을 이해하고 나니, 오히려 단순해졌습니다. **"이 코드는 무엇을 하는가?"** **"다른 코드와 어떤 관계인가?"** 이 두 가지 질문만으로도 모듈을 설계할 수 있다는 것을 깨달았습니다. 복잡한 패턴이나 기법보다, 명확한 책임과 의존성 관리가 더 중요했습니다.

**기초의 중요성:**

우테코를 통해 내가 얼마나 많은 것을 모르는지를 알게 되었고, 방향성을 잡게 되었습니다. 단순히 웹 개발도 좋지만, 코어 개발도 재밌다는 것을 깨달았습니다. React 컴파일러 기여 경험을 통해, 프레임워크나 라이브러리의 내부를 이해하고 개선하는 것도 매우 재미있다는 것을 느꼈습니다.

**깨달은 점:**

- **표면적 학습의 한계**: React, Next.js도 내부 동작 원리를 모른 채 메서드만 공부해서 쓰고 있었습니다. "이렇게 하면 작동한다"는 것을 알았지만, "왜 이렇게 작동하는지"는 몰랐습니다. 이것이 복잡한 문제를 해결할 때 한계가 되었습니다.

- **모듈의 본질**: 모듈 시스템에 대한 이해도 없이 모듈을 만들려고 했습니다. "모듈"이라는 단어로 각 모듈을 테스트한다거나, 특정 패턴을 적용하려고 했지만, 모듈의 본질을 이해하지 못한 채 사용하고 있었습니다. 모듈의 본질은 "관심사의 분리"와 "의존성 관리"라는 것을 배웠습니다.

- **기초의 중요성**: 우테코를 통해 내가 얼마나 무엇을 모르는지를 알게 되었고, 방향성을 잡게 되었습니다. 단순히 웹 개발도 좋지만, 코어 개발도 재밌다는 것을 깨달았습니다. 기초 지식을 쌓는 것이 더 깊이 있는 개발을 하는 데 필수적이라는 것을 배웠습니다.

### 2. 과정의 가치

완성도 100%가 아니라, 도전하고 배우는 과정이 중요하다는 것을 깨달았습니다. 실패하더라도 그 과정에서 배운 것이 있다면 그것은 실패가 아닙니다.

### 3. 현실적 판단의 중요성

처음에는 완전한 마이그레이션을 목표로 했지만, 시간과 난이도를 고려하여 현실적으로 마무리했습니다. 이것이 오히려 더 나은 선택이었습니다.

### 4. 코드 품질의 중요성

리팩토링과 테스트 코드 추가를 통해 코드 품질의 중요성을 깨달았습니다. "작동하는 코드"만으로는 부족하고, 유지보수 가능하고 테스트 가능한 코드가 진짜 좋은 코드라는 것을 배웠습니다.

### 5. 자동화와 DX의 가치

React 컴파일러 기여 경험을 통해 DX(Developer Experience) 향상의 재미를 느꼈고, 자동화에 빠지게 되었습니다.

**React 컴파일러가 주는 영감:**

React 컴파일러는 개발자가 수동으로 `useMemo`, `useCallback`을 추가하지 않아도, 자동으로 최적화해줍니다. 이것이 바로 **"반복적인 작업을 자동화해서 개발자가 본질에 집중하게 하는 것"**입니다.

마찬가지로:

- `i18nexus-tools`의 `t-wrapper`는 개발자가 수동으로 `t()` 함수를 추가하지 않아도 자동으로 변환해줍니다.
- Bruno 기반 자동화 도구는 개발자가 수동으로 쿼리를 작성하지 않아도 자동으로 생성해줍니다.

**자동화의 핵심 가치:**

1. **반복 작업 제거**: 개발자가 반복적으로 하는 작업을 자동화합니다.
2. **실수 방지**: 수동으로 하면 실수할 수 있는 작업을 자동화해서 안전하게 만듭니다.
3. **본질에 집중**: 기술적 세부사항보다 비즈니스 로직에 집중할 수 있게 합니다.

우리 팀의 Bruno 기반 자동화 도구도 결국 개발자 경험을 향상시키고, 비즈니스 로직에 집중할 수 있게 하는 것이 목표입니다. 이런 자동화 도구를 만드는 것이 **코어 개발의 재미**이고, 제가 앞으로 계속 추구하고 싶은 방향입니다.

## 결론

2주 동안 Rust 마이그레이션을 완전히 끝내지는 못했지만, 이 과정에서 많은 것을 배웠습니다. Rust 언어의 기초, AST 조작, 시스템 프로그래밍의 기초를 배웠고, 더 중요한 것은 "도전하고 배우는 과정"의 가치를 깨달았다는 것입니다.

**기술적 성과:**

약 40% 정도 진행했지만, 핵심 구조는 완성했습니다. `parser.rs`로 파일 파싱과 코드 생성이 가능해졌고, `ast_transformers.rs`로 AST 변환의 기본 구조를 만들었습니다. `import_manager.rs`에서 `useTranslation` 훅을 AST 노드로 생성하는 것도 구현했습니다. 함수 탐색 로직도 추가해서, React 컴포넌트를 찾아서 변환하는 기본 흐름이 완성되었습니다.

물론 아직 완성되지 않은 부분도 많습니다. 함수 body에 `useTranslation` 훅을 추가하는 로직, `use client` 디렉티브 추가, 서버 모드 처리 등이 남아있습니다. 하지만 이 과정에서 배운 것이 더 중요했습니다.

**가장 큰 배움:**

하지만 가장 큰 배움은 내가 얼마나 많은 것을 모르는지 알게 된 것이었습니다. React, Next.js의 내부 동작 원리를 모르고 있었고, 모듈 시스템에 대한 이해도 부족했습니다. 우테코를 통해 이러한 기초 지식의 중요성을 깨달았고, 방향성을 잡게 되었습니다.

단순히 웹 개발도 좋지만, 코어 개발도 재밌다는 것을 느꼈습니다. React 컴파일러 기여 경험을 통해 DX 향상의 재미를 느꼈고, 자동화에 빠지게 되었습니다. 이러한 경험들이 모두 연결되어, 더 나은 개발자로 성장할 수 있는 기반을 마련했습니다.

**오픈 미션의 가치:**

오픈 미션이 "결과물의 완성도보다 과정을 중시한다"는 것을 직접 경험했습니다. 처음에는 완전한 마이그레이션을 목표로 했지만, 시간과 난이도를 고려하여 현실적으로 마무리했습니다. 이것이 오히려 더 나은 선택이었습니다.

실패하더라도 그 과정에서 배운 것이 있다면 그것은 실패가 아닙니다. Rust를 처음 접해서 많은 어려움을 겪었지만, 그 과정에서 메모리 관리, 타입 시스템, AST 조작 등 많은 것을 배웠습니다. 이것이 앞으로 더 나은 개발자로 성장할 수 있는 기반이 되었습니다.

**연결된 경험들:**

이번 오픈 미션은 단순히 Rust를 배우는 것이 아니라, 여러 경험들이 연결되는 계기가 되었습니다. AI로만 개발했을 때의 문제점, 리팩토링의 필요성, 테스트 코드의 중요성, React 컴파일러 기여 경험, 자동화에 대한 관심, 모듈 시스템에 대한 이해 부족 등이 모두 연결되어, 앞으로의 학습 방향을 결정하는 중요한 경험이 되었습니다.

## 몰입의 경험

### 시간 투자

이번 오픈 미션에 투자한 시간을 계산해보니, 약 **80~100시간** 정도였습니다. 2주 동안 하루 평균 6~7시간을 투자했고, 주말에는 거의 10시간 이상 몰입했습니다.

**하루 일과:**

- 오전 9시 ~ 12시: Rust 학습 및 코드 작성
- 점심 시간 (12시 ~ 1시)
- 오후 1시 ~ 6시: 실제 구현 및 디버깅
- 저녁 식사 (6시 ~ 7시)
- 저녁 7시 ~ 10시: 테스트 작성 및 문서 정리
- 자기 전: 내일 할 일 정리

주말에는 거의 하루 종일 몰입했습니다. 특히 컴파일 에러를 해결하거나, AST 구조를 이해하는데 몰입하면 시간 가는 줄 몰랐습니다.

### 몰입의 순간들

**순간 1: 첫 번째 컴파일 성공**

Rust 코드를 처음 작성하고, 수십 개의 컴파일 에러를 하나씩 해결한 끝에 처음으로 컴파일에 성공했을 때의 기쁨은 잊을 수 없습니다. "드디어!"라고 소리쳤던 기억이 납니다.

**순간 2: AST 변환 성공**

`visit_mut_expr`로 문자열 리터럴을 `t()` 호출로 변환하는데 성공했을 때, 정말 신기했습니다. 코드가 다른 코드를 변환한다는 것이 처음에는 추상적으로 느껴졌는데, 실제로 작동하는 것을 보니 감동이었습니다.

**순간 3: 테스트 통과**

E2E 테스트가 처음으로 통과했을 때, 정말 뿌듯했습니다. 2주 동안의 노력이 결실을 맺는 순간이었습니다.

### "와, 나 진짜 너무 열심히 살았다"

오픈 미션을 마무리하면서, 정말 이 말이 절로 나왔습니다. 2주 동안 정말 열심히 살았고, 몰입했습니다. 처음에는 불가능해 보였던 Rust 마이그레이션에 도전했고, 완성하지는 못했지만 그 과정에서 많은 것을 배웠습니다.

이 경험은 제 개발자 인생에서 중요한 전환점이 될 것 같습니다. 단순히 웹 개발만 하는 개발자가 아니라, 더 깊이 있는 개발을 하는 개발자가 되고 싶다는 목표가 생겼습니다.

## 커뮤니티 활동 및 학습 태도

### 디스코드 활동

프리코스 기간 동안 디스코드에서 적극적으로 활동했습니다. 모르는 것이 있으면 질문했고, 다른 사람의 질문에도 답변했습니다.

**질문한 내용들:**

- Rust 소유권 개념에 대한 질문
- SWC AST 구조에 대한 질문
- `Wtf8Atom` 문자열 변환 방법
- 테스트 작성 방법

**답변한 내용들:**

- TypeScript 타입 관련 질문
- React 컴포넌트 설계 질문
- Next.js 라우팅 관련 질문

다른 사람들과 소통하면서 배우는 것이 얼마나 즐거운지 깨달았습니다. 혼자 고민하는 것보다, 함께 고민하고 해결하는 것이 더 효과적이고 재미있었습니다.

### 학습한 내용 공유

Rust를 학습하면서 배운 내용을 정리해서 디스코드에 공유했습니다. 특히 소유권 개념이나 AST 조작 같은 내용을 다른 사람들과 공유하면서, 제 자신도 더 깊이 이해할 수 있었습니다.

**공유한 내용들:**

- Rust 소유권 개념 정리
- SWC AST 구조 이해하기
- VisitMut 패턴 사용법
- 테스트 작성 팁

다른 사람에게 설명하면서, 제가 얼마나 이해했는지 확인할 수 있었습니다. 제대로 이해하지 못한 부분은 설명하기 어려웠고, 그것을 다시 공부하는 계기가 되었습니다.

### 동료에 대한 기여

다른 사람들의 코드를 리뷰하면서, 함께 성장하는 즐거움을 느꼈습니다. 특히 TypeScript 코드나 React 컴포넌트 설계에 대한 피드백을 주면서, 제 자신도 더 성장할 수 있었습니다.

**코드 리뷰:**

- 코드 구조 개선 제안
- 테스트 코드 추가 제안
- 타입 안전성 개선 제안

다른 사람의 코드를 보면서, 다양한 접근 방법을 배울 수 있었습니다. 같은 문제를 다르게 해결하는 방법을 보면서, 제 시야가 넓어졌습니다.

## 우테코에 대한 기대

### 함께 성장하는 문화

우테코의 "함께 성장하는 문화"가 가장 매력적으로 느껴집니다. 프리코스 기간 동안 디스코드에서 다른 사람들과 소통하면서, 함께 성장하는 즐거움을 느꼈습니다. 우테코에 합격하면, 더 많은 동료들과 함께 성장하고 싶습니다.

### 깊이 있는 학습

우테코의 교육 철학이 "깊이 있는 학습"에 초점을 맞춘다는 것이 인상적입니다. 단순히 프레임워크를 사용하는 것이 아니라, 내부 동작 원리를 이해하고, 더 나은 코드를 작성하는 것을 목표로 한다는 것이 제가 추구하는 방향과 일치합니다.

### 도전과 몰입

우테코의 "도전과 몰입"이라는 가치가 이번 오픈 미션을 통해 더욱 와닿았습니다. 컴포트 존을 벗어나는 도전이 얼마나 가치 있는지, 그리고 몰입하는 경험이 얼마나 즐거운지 깨달았습니다. 우테코에서 더 많은 도전과 몰입을 경험하고 싶습니다.

## 향후 계획

### 단기 계획 (3개월)

- **기초 지식 학습**: React, Next.js의 내부 동작 원리를 깊이 있게 학습합니다. 단순히 사용하는 것이 아니라, 왜 이렇게 작동하는지 이해하고 싶습니다.
- **모듈 시스템 이해**: 모듈의 본질을 이해하고 올바르게 설계하는 방법을 학습합니다. 관심사의 분리, 의존성 관리 등을 깊이 있게 공부하고 싶습니다.
- **Rust 학습 지속**: Rust 학습을 지속적으로 진행하고, 이번 오픈 미션에서 시작한 마이그레이션을 완성하고 싶습니다.

### 중기 계획 (6개월)

- **코어 개발 경험 확대**: React 컴파일러 같은 오픈소스 프로젝트에 더 많이 기여하고 싶습니다. 프레임워크나 라이브러리의 내부를 이해하고 개선하는 경험을 쌓고 싶습니다.
- **자동화 도구 완성**: Bruno 기반 자동화 도구를 완성하고 팀에 적용합니다. 개발자 경험을 향상시키는 도구를 만드는 것이 목표입니다.
- **블로그 운영**: 학습한 내용을 블로그에 정리해서 공유합니다. 다른 사람들과 지식을 공유하면서, 제 자신도 더 깊이 이해하고 싶습니다.

### 장기 계획 (1년)

- **깊이 있는 개발자**: 단순히 웹 개발만 하는 개발자가 아니라, 더 깊이 있는 개발을 하는 개발자가 되고 싶습니다. 시스템 프로그래밍, 컴파일러, AST 조작 등 다양한 영역을 경험하고 싶습니다.
- **커뮤니티 기여**: 오픈소스 프로젝트에 지속적으로 기여하고, 커뮤니티에 가치를 더하고 싶습니다.
- **멘토링**: 제가 배운 것을 다른 사람들과 공유하고, 함께 성장하고 싶습니다.

## 마무리

이번 오픈 미션은 제 개발자 인생에서 가장 중요한 경험 중 하나가 될 것입니다. Rust를 처음 접해서 많은 어려움을 겪었지만, 그 과정에서 얻은 배움이 더 가치 있었습니다.

**이 경험을 통해 배운 것:**

1. **컴포트 존을 벗어나는 도전의 가치**: 익숙한 것에서 벗어나야 진정한 성장이 있다는 것을 배웠습니다.
2. **완성도보다 과정의 중요성**: 완벽한 결과물을 만드는 것이 아니라, 도전하고 배우는 과정이 더 중요하다는 것을 깨달았습니다.
3. **실패를 통한 학습**: 실패하더라도 그 과정에서 배운 것이 있다면 그것은 실패가 아니라는 것을 경험했습니다.
4. **함께 성장하는 즐거움**: 혼자 고민하는 것보다, 함께 고민하고 해결하는 것이 더 효과적이고 재미있다는 것을 느꼈습니다.
5. **기초 지식의 중요성**: 표면적인 지식이 아니라, 깊은 이해가 더 나은 개발자가 되는 데 필수적이라는 것을 배웠습니다.

**우테코에 바라는 것:**

우테코가 단순히 코딩 실력을 향상시키는 곳이 아니라, **함께 성장하고 도전하며 깊이 있게 학습하는 곳**이라는 것을 프리코스를 통해 느꼈습니다. 저도 우테코의 일원이 되어, 더 많은 동료들과 함께 성장하고 싶습니다.

이번 오픈 미션을 통해 "와, 나 진짜 너무 열심히 살았다"라는 생각이 들었고, 앞으로도 이런 열정을 가지고 계속 도전하고 성장하고 싶습니다.

**감사의 말:**

프리코스 기간 동안 함께 고민하고 성장한 모든 분들께 감사드립니다. 디스코드에서 질문에 답변해주신 분들, 코드 리뷰를 해주신 분들, 격려해주신 분들 모두 감사합니다. 이 경험이 있었기에, 저도 더 성장할 수 있었습니다.

그리고 우테코 크루 분들께도 감사드립니다. 이런 좋은 기회를 주셔서 감사하고, 프리코스를 통해 많은 것을 배울 수 있었습니다. 우테코에 합격해서, 더 많은 것을 배우고 함께 성장하는 기회를 얻고 싶습니다.

**마지막으로:**

이 소감문을 쓰면서, 2주 동안의 경험을 다시 돌아보게 되었습니다. 정말 많은 것을 배웠고, 성장했습니다. 완성도는 40% 정도지만, 배움은 100%입니다.

앞으로도 이런 도전을 계속하고, 더 나은 개발자가 되기 위해 노력하겠습니다. 우테코에서 만날 수 있기를 기대합니다.

---

_이 소감문은 우테코 8기 오픈 미션 제출용으로 작성되었습니다._

_작성 일자: 2025년 11월_
