# WrappedT 컴포넌트 아이디어 분석

## 아이디어 개요

빌드 시점에 모든 JSX 텍스트를 `<WrappedT>` 컴포넌트로 감싸서, 서버 컴포넌트에서도 번역을 지원할 수 있지 않을까 하는 아이디어였습니다.

### 변환 예시

```jsx
// 변환 전
<div>안녕하세요</div>

// 변환 후
<div>
  <WrappedT>안녕하세요</WrappedT>
</div>
```

### 핵심 아이디어

1. **빌드 시점 자동 변환**: 개발자가 수동으로 작업할 필요 없음
2. **서버 컴포넌트 지원**: JSX 텍스트를 컴포넌트로 감싸서 번역 가능
3. **로직 내 `t()` 함수**: `alert()`, 이벤트 핸들러 등은 이미 클라이언트 컴포넌트이므로 문제없음

## 왜 이렇게 생각했는가?

### 1. 단순하고 직관적인 접근

JSX 텍스트를 컴포넌트로 감싸는 것이 가장 직관적으로 보였습니다. 개발자가 작성한 코드를 최소한으로 변경하면서도 번역 기능을 추가할 수 있다고 생각했습니다.

```jsx
// 개발자가 작성
<div>안녕하세요</div>

// 자동으로 변환
<div><WrappedT>안녕하세요</WrappedT></div>
```

### 2. 서버 컴포넌트 지원의 필요성

Next.js App Router에서 서버 컴포넌트가 기본이 되면서, 서버 컴포넌트에서도 번역이 필요했습니다. 하지만 `useTranslation()` 훅은 클라이언트 컴포넌트에서만 사용 가능하므로, 다른 방법이 필요했습니다.

### 3. 빌드 시점 변환의 장점

- **자동화**: 개발자가 수동으로 `t()` 함수를 추가할 필요 없음
- **일관성**: 모든 텍스트가 동일한 방식으로 처리됨
- **투명성**: 개발자가 작성한 코드와 최종 코드의 차이가 최소화

## 왜 이렇게 구현하지 못했는가?

### 문제 1: 클라이언트 컴포넌트 경계 생성

`<WrappedT>`는 React 컴포넌트이므로, 서버 컴포넌트에서 사용하면 클라이언트 경계가 생성됩니다.

```jsx
// 서버 컴포넌트
export default async function Page() {
  return (
    <div>
      <WrappedT>안녕하세요</WrappedT>  // ❌ 클라이언트 경계 생성
      <WrappedT>반갑습니다</WrappedT>   // ❌ 클라이언트 경계 생성
      <WrappedT>환영합니다</WrappedT>   // ❌ 클라이언트 경계 생성
    </div>
  )
}
```

**문제점:**
- 모든 텍스트마다 클라이언트 경계가 생성됨
- 서버 컴포넌트의 장점(서버 렌더링, 번들 크기 감소) 상실
- Hydration 오버헤드 증가

### 문제 2: 성능 저하

```jsx
// 이렇게 되면
<div>
  <WrappedT>안녕하세요</WrappedT>  // 클라이언트 경계 1
  <WrappedT>반갑습니다</WrappedT>   // 클라이언트 경계 2
  <WrappedT>환영합니다</WrappedT>   // 클라이언트 경계 3
</div>
```

**성능 영향:**
- 각 `<WrappedT>`마다 별도의 클라이언트 컴포넌트로 번들링
- Hydration 비용 증가
- 초기 로딩 속도 저하
- 번들 크기 증가

### 문제 3: 서버 컴포넌트의 장점 상실

서버 컴포넌트의 핵심 가치:
- **서버에서 렌더링**: 클라이언트로 HTML만 전송
- **번들 크기 감소**: 클라이언트에 JavaScript 전송 불필요
- **SEO 최적화**: 서버에서 완전히 렌더링된 HTML

`<WrappedT>`를 사용하면:
- 클라이언트에서 다시 렌더링 필요
- JavaScript 번들에 포함됨
- SEO 이점 감소

### 문제 4: React의 컴포넌트 경계 규칙

Next.js App Router에서는 서버 컴포넌트와 클라이언트 컴포넌트의 경계가 명확합니다:

```jsx
// 서버 컴포넌트
export default async function Page() {
  // 서버에서 실행
  return <div>안녕하세요</div>
}

// 클라이언트 컴포넌트
'use client'
export default function ClientPage() {
  // 클라이언트에서 실행
  return <div>안녕하세요</div>
}
```

`<WrappedT>`를 사용하면 모든 텍스트가 클라이언트 컴포넌트가 되어, 서버 컴포넌트의 이점을 잃게 됩니다.

## 현재 t-wrapper의 접근 방식

### 함수 호출 방식

현재 t-wrapper는 JSX 텍스트를 `t()` 함수 호출로 변환합니다:

```jsx
// 변환 전
<div>안녕하세요</div>

// 변환 후 (서버 컴포넌트)
<div>{t('안녕하세요')}</div>

// 서버 컴포넌트에서는
async function ServerComponent() {
  const { t } = await getServerTranslation();
  return <div>{t('안녕하세요')}</div>;
}

// 클라이언트 컴포넌트에서는
'use client'
function ClientComponent() {
  const { t } = useTranslation();
  return <div>{t('안녕하세요')}</div>;
}
```

### 장점

1. **서버/클라이언트 모두 지원**: 컴포넌트 타입에 따라 적절한 방식 사용
2. **성능 최적화**: 추가 컴포넌트 없이 함수 호출만 사용
3. **번들 크기 최소화**: 불필요한 클라이언트 컴포넌트 생성 없음
4. **Next.js 권장 방식과 일치**: React 팀과 Next.js 팀이 권장하는 패턴

## 대안 접근 방법

### 방법 1: 빌드 시점 직접 번역 (Static Generation)

```jsx
// 빌드 전
<div>안녕하세요</div>

// 빌드 후 (locale이 'ko'일 때)
<div>안녕하세요</div>

// 빌드 후 (locale이 'en'일 때)
<div>Hello</div>
```

**장점:**
- 서버 컴포넌트에서 완벽하게 작동
- 런타임 오버헤드 없음
- SEO 최적화

**단점:**
- 동적 locale 변경 불가
- locale별로 별도 빌드 필요

### 방법 2: 서버 함수로 변환 (현재 방식)

```jsx
// 빌드 전
<div>안녕하세요</div>

// 빌드 후
<div>{t('안녕하세요')}</div>

// t 함수는 서버에서 동기적으로 번역 반환
function t(key: string) {
  const locale = getServerLocale();
  return translations[locale][key];
}
```

**장점:**
- 서버 컴포넌트에서 작동
- 동적 locale 지원
- 런타임 오버헤드 최소

**단점:**
- 서버 컴포넌트와 클라이언트 컴포넌트 구분 필요

### 방법 3: 하이브리드 접근 (현재 t-wrapper 방식)

```jsx
// 서버 컴포넌트
<div>{t('greeting')}</div>  // 서버에서 동기 번역

// 클라이언트 컴포넌트
'use client'
function MyComponent() {
  const { t } = useTranslation();  // 클라이언트 훅 사용
  return <div>{t('greeting')}</div>;
}
```

**변환 로직:**
1. 컴포넌트가 서버 컴포넌트인지 확인
2. 서버 컴포넌트면 → `t('key')` 함수 호출로 변환
3. 클라이언트 컴포넌트면 → `useTranslation()` 훅 추가 + `t('key')` 사용

## 결론

### 왜 `<WrappedT>` 방식이 적합하지 않은가?

1. **성능 문제**: 모든 텍스트마다 클라이언트 경계 생성
2. **번들 크기**: 불필요한 클라이언트 컴포넌트 증가
3. **서버 컴포넌트 장점 상실**: 서버 렌더링 이점 감소
4. **Hydration 오버헤드**: 각 컴포넌트마다 hydration 필요

### 현재 방식이 더 나은 이유

1. **함수 호출 방식**: 추가 컴포넌트 없이 함수 호출만 사용
2. **서버/클라이언트 구분**: 각 환경에 최적화된 방식 사용
3. **성능 최적화**: 불필요한 클라이언트 컴포넌트 생성 없음
4. **Next.js 권장 방식**: React 팀과 Next.js 팀이 권장하는 패턴

### 교훈

- **단순해 보이는 해결책이 항상 최선은 아니다**: 직관적인 접근이 성능 문제를 야기할 수 있음
- **프레임워크의 철학 이해**: Next.js의 서버 컴포넌트 철학을 이해하고 그에 맞는 접근 필요
- **성능과 사용성의 균형**: 개발자 경험뿐만 아니라 런타임 성능도 고려해야 함

---

**작성 일자**: 2025년 11월  
**관련 문서**: `t-wrapper` 구현, Next.js App Router 서버 컴포넌트

