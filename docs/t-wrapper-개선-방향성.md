# t-wrapper 개선 방향성 (AS-IS → TO-BE)

## AS-IS
- 파일 단위 직렬 처리: 읽기 → 파싱(Babel) → traverse 변환 → 코드 생성/쓰기
- 단일 프로세스/싱글 스레드 중심
- 파일 간 컨텍스트 고려 낮음(공유 상수, import 그래프 등은 최소)
- SWC는 실험 상태(호환 계층 비용으로 실이득 낮음)
- 콘솔 출력 최소화(에러 중심), 리포트는 별도
- 상수/규칙은 `scripts/t-wrapper/constants.ts`로 중앙화됨

## TO-BE
1) 병렬 처리
   - Rust(t-wrapper-rust): Rayon 기반 `par_iter`로 파일 병렬 처리
   - 파이프라인화(read → parse/transform → write), bounded 채널로 백프레셔
2) 파서/성능
   - SWC 파서 본격 적용(필요 노드만 Babel 호환 변환)
   - 메모리 재사용(버퍼 풀, Arena 고려), I/O 배치 최적화
3) 2-pass 설계(선택)
   - Pass1: 메타 수집(컴포넌트/서버컴포넌트/공유상수)
   - Pass2: 정책 반영 변환(정확도 ↑, 불필요 변환 ↓)
4) 컨텍스트 확장
   - 파일 간 참조/그래프 분석(공유 상수, 외부 import 영향)
   - 변경 감지 캐시(mtime+크기+해시)로 재처리 최소화
5) 개발 DX
   - 에러/결과 리포트 구조화(JSON/파일 출력 옵션)
   - 상세 로그는 플래그 기반으로만 출력

## 단계적 로드맵
- Step 1: Rust에서 파일 병렬 처리 적용(안전한 동시성, per-file 에러 격리)
- Step 2: 파이프라인화 및 bounded 채널 도입(메모리 안정성)
- Step 3: SWC 파서 정착(필요 노드만 변환 → Babel traverse 최소화/제거)
- Step 4: 2-pass 및 컨텍스트 분석 도입(정확도/성능 동시 개선)
- Step 5: 리포트/옵션 정리(자동화/CI 친화적 출력 형식)

## 기대 효과
- 파일 수에 선형 확장 가능한 처리량(코어 수 활용 극대화)
- 파싱/변환 비용 절감(SWC + 변환 최소화)
- 불필요 작업 감소(변경 감지/2-pass 스킵)
- 운영/배포 친화적 리포팅 및 안정성 향상


